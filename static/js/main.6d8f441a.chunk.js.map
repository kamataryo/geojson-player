{"version":3,"sources":["util.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["noAltMapper","lng","lat","readGeoJSON","file","type","Promise","resolve","reject","filereader","FileReader","onload","geojson","JSON","parse","result","features","geometry","Array","isArray","properties","coordTimes","length","coordinates","Error","error","console","handledError","gpxtext","gpx","DOMParser","parseFromString","tj","map","gpx2geojson","onerror","_e","readAsText","sleep","msec","setTimeout","createRecorder","canvas","url","chunks","stream","captureStream","mediaRecorder","MediaRecorder","mimeType","ondataavailable","event","push","data","onstop","blob","Blob","URL","createObjectURL","startRecord","start","stopRecord","a","stop","animate","trace","ends","speed","growingLine","addSource","addLayer","id","source","layout","paint","filter","handler","Date","getTime","cursor","loop","requestAnimationFrame","past","durations","coord","getSource","setData","cancelAnimationFrame","download","link","document","createElement","href","body","appendChild","dispatchEvent","MouseEvent","bubbles","cancelable","view","window","removeChild","App","useState","setTrace","setEnds","setSpeed","recording","setRecording","mapRef","useRef","onDrop","useCallback","files","name","toLocaleLowerCase","endsWith","toLowerCase","index","initialTime","currentTime","pointLength","isStart","isEnd","onLoad","current","on","bounds","reduce","extend","mapboxgl","maplibregl","LngLatBounds","fitBounds","padding","duration","handleSpeed","e","parseInt","currentTarget","value","handleStart","getCanvas","removeLayer","removeSource","handleStop","count","totalDuration","style","width","height","data-hash","Control","containerProps","className","position","htmlFor","min","max","onChange","disabled","Math","round","classnames","onClick","display","justifyContent","alignItems","sx","color","getRootProps","getInputProps","isDragActive","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.6d8f441a.chunk.js","sourcesContent":["// @ts-ignore\nimport tj from '@mapbox/togeojson'\nimport maplibregl from 'maplibre-gl';\nimport { DOMParser } from 'xmldom'\nimport { EndGeoJSON, TraceGeoJSON } from './App';\n\nconst noAltMapper = ([lng, lat, alt]: any[]) => [lng, lat]\n\nconst gpx2geojson = (gpxtext: string) => {\n\tconst gpx = new DOMParser().parseFromString(gpxtext);\n\tconst geojson = tj.gpx(gpx)\n\tgeojson.features[0].geometry.coordinates = geojson.features[0].geometry.coordinates.map(noAltMapper)\n\treturn geojson\n}\n\n// GPX sample transformed in GeoJSON\n// [\n//   {\n//     type: 'Feature',\n//     properties: {\n//       name: '赤穂市 ｶﾔｯｸ',\n//       type: 'whitewater_rafting_kayaking',\n//       time: '2020-10-07T23:05:14.000Z',\n//       coordTimes: [Array]\n//     },\n//     geometry: { type: 'LineString', coordinates: [Array] }\n//   }\n// ]\n\n/**\n *\n * @param {File} file\n * @returns\n */\n export const readGeoJSON = (file: File, type: 'GeoJSON' | 'GPX') => {\n\treturn new Promise<TraceGeoJSON>((resolve, reject) => {\n\t  const filereader = new FileReader();\n\t  filereader.onload = () => {\n          if(type === 'GeoJSON') {\n\t\ttry {\n\t\t\tconst geojson = JSON.parse(filereader.result as string);\n\t\t\tif (\n\t\t\t  !geojson.features ||\n\t\t\t  geojson.features[0].geometry.type !== \"LineString\" ||\n        !Array.isArray(geojson.features[0].properties.coordTimes) ||\n        geojson.features[0].properties.coordTimes.length !== geojson.features[0].geometry.coordinates.length\n      ) {\n\t\t\t  throw new Error();\n\t\t\t}\n\t\t\tresolve(geojson as TraceGeoJSON);\n\t\t      } catch (error) {\n\t\t\tconsole.error(error);\n\t\t\tconst handledError = new Error(\"Should be a GeoJSON with LineString.\");\n\t\t\treject(handledError);\n\t\t      }\n\t  } else {\n\t\t  try {\n\n\t\tconst gpxtext = filereader.result as string;\n\t\tconst geojson = gpx2geojson(gpxtext)\n\t\tresolve(geojson as TraceGeoJSON)\n\t\t} catch (error) {\n\t\t\tconsole.error(error);\n\t\t\tconst handledError = new Error(\"Should be a valid GPX.\");\n\t\t\treject(handledError);\n\t\t}\n\t  }\n\n\t  };\n\t  filereader.onerror = (_e) => {\n\t    console.error(_e);\n\t    const handledError = new Error(\"Failed to read the file.\");\n\t    reject(handledError);\n\t  };\n\t  filereader.readAsText(file);\n\t});\n};\n\nexport const sleep = (msec: number) => new Promise((resolve) => setTimeout(resolve, msec));\n\n\nexport const createRecorder = (canvas: HTMLCanvasElement) => {\n\tlet url = \"\";\n\tconst chunks: Blob[] = [];\n\tconst stream = canvas.captureStream(120);\n\n\tconst mediaRecorder = new MediaRecorder(stream, {\n\t  mimeType: \"video/webm; codecs=vp9\",\n\t});\n\n\tmediaRecorder.ondataavailable = (event) => {\n\t  chunks.push(event.data);\n\t};\n\n\tmediaRecorder.onstop = () => {\n\t  const blob = new Blob(chunks, {\n\t    type: \"video/webm\",\n\t  });\n\t  url = URL.createObjectURL(blob);\n\t};\n\n\treturn {\n\t  startRecord: () => {\n\t    mediaRecorder.start();\n\t  },\n\t  stopRecord: async () => {\n\t    mediaRecorder.stop();\n\t    while (!url) {\n\t      await sleep(10);\n\t    }\n\t    return url;\n\t  },\n\t};\n};\n\nexport const animate = (\n  trace: TraceGeoJSON,\n  ends: EndGeoJSON,\n  map: maplibregl.Map,\n  { speed }:  { speed: number },\n\t): Promise<void> => {\n\n  const growingLine: GeoJSON.FeatureCollection<GeoJSON.LineString> = {\n    type: 'FeatureCollection',\n    features: [\n      {\n        type: 'Feature',\n        properties: {},\n        geometry: {\n          type: 'LineString',\n          coordinates: [],\n        },\n      },\n    ],\n  }\n\n  map.addSource('gp-growing-line', { type: 'geojson', data: growingLine })\n  map.addSource('gp-growing-ends', { type: 'geojson', data: ends })\n  map.addLayer({\n    id: 'gp-growing-line',\n    type: 'line',\n    source: 'gp-growing-line',\n    layout: {},\n    paint: {\n      'line-width': 3,\n      'line-color': 'red'\n    }\n  })\n  map.addLayer({\n    id: 'gp-growing-ends-start',\n    type: 'circle',\n    source: 'gp-growing-ends',\n    layout: {},\n    filter: ['==', 'isStart', true],\n    paint: {\n      'circle-radius': 8,\n      'circle-color': 'red'\n    }\n  })\n\n\treturn new Promise((resolve => {\n\n    let start = new Date().getTime();\n    let cursor: number = 0;\n    let handler\n\n    (function loop() {\n      handler = requestAnimationFrame(loop);\n      const current = new Date().getTime();\n      const past = (current - start) * speed\n\n      const durations = trace.features[0].properties.durations || []\n      while(past > durations[cursor]) {\n        const coord = trace.features[0].geometry.coordinates[cursor]\n        growingLine.features[0].geometry.coordinates.push(coord)\n        cursor++\n      }\n      // @ts-ignore\n      map.getSource(\"gp-growing-line\").setData(growingLine);\n\n      if(growingLine.features[0].geometry.coordinates.length >= trace.features[0].geometry.coordinates.length) {\n        map.addLayer({\n          id: 'gp-growing-ends-end',\n          type: 'circle',\n          source: 'gp-growing-ends',\n          layout: {},\n          filter: ['==', 'isEnd', true],\n          paint: {\n            'circle-radius': 8,\n            'circle-color': 'red'\n          }\n        })\n        cancelAnimationFrame(handler)\n        resolve()\n      }\n    })()\n  }))\n};\n\n\nexport const download = (url: string) => {\n  const link = document.createElement(\"a\");\n  link.href = url;\n  link.download = \"movie.webm\";\n  document.body.appendChild(link);\n  link.dispatchEvent(\n    new MouseEvent(\"click\", {\n      bubbles: true,\n      cancelable: true,\n      view: window,\n    })\n  );\n  document.body.removeChild(link);\n};\n","import React, { useCallback, useState, useRef } from 'react';\nimport './App.css';\nimport Dropzone from 'react-dropzone'\nimport { GeoloniaMap } from '@geolonia/embed-react'\nimport classnames from 'classnames'\nimport { animate, createRecorder, download, readGeoJSON, sleep,  } from './util';\nimport { Map } from 'maplibre-gl';\nimport VideocamIcon from '@mui/icons-material/Videocam';\nimport StopIcon from '@mui/icons-material/Stop';\n\nexport type TraceGeoJSON = GeoJSON.FeatureCollection<GeoJSON.LineString, { coordTimes: string[], durations?: number[] }>\nexport type EndGeoJSON = GeoJSON.FeatureCollection<GeoJSON.Point, { isStart?: boolean, isEnd?: boolean }>\n\nfunction App() {\n\n  const [trace, setTrace] = useState<TraceGeoJSON>()\n  const [ends, setEnds] = useState<EndGeoJSON>()\n  const [speed, setSpeed] = useState(100)\n  const [recording, setRecording] = useState(false)\n  const mapRef = useRef<Map>();\n\n  const onDrop = useCallback(async (files) => {\n    const file = files[0] as File\n    let trace: TraceGeoJSON\n    if(file.name.toLocaleLowerCase().endsWith('.gpx')) {\n      trace = await readGeoJSON(file, 'GPX')\n    } else if(file.name.toLowerCase().endsWith('.geojson')) {\n      trace = await readGeoJSON(file, 'GeoJSON')\n    } else {\n      return\n    }\n\n    // enrich tarce\n    for (let index = 0; index < trace.features[0].geometry.coordinates.length; index++) {\n      if(!trace.features[0].properties.durations) {\n        trace.features[0].properties.durations = []\n      }\n      const initialTime = trace.features[0].properties.coordTimes[0]\n      const currentTime = trace.features[0].properties.coordTimes[index];\n      trace.features[0].properties.durations!.push(new Date(currentTime).getTime() - new Date(initialTime).getTime())\n    }\n\n    const pointLength = trace.features[0].geometry.coordinates.length\n    const ends: EndGeoJSON  = {\n      type: 'FeatureCollection',\n      features: [\n        { type: 'Feature', properties: { isStart: true }, geometry: { type: 'Point', coordinates: trace.features[0].geometry.coordinates[0] } },\n        { type: 'Feature', properties: { isEnd: true }, geometry: { type: 'Point', coordinates: trace.features[0].geometry.coordinates[pointLength - 1] } }\n      ]\n    }\n\n    setTrace(trace)\n    setEnds(ends)\n  }, [])\n\n  const onLoad = useCallback((map) => {\n    mapRef.current = map\n    map.on('load', () => {\n\n      if(!trace || !ends) { return }\n\n      const bounds = trace.features[0].geometry.coordinates.reduce(\n        (bounds, coord) => {\n          return bounds.extend(coord);\n        },\n        new (\n          // @ts-ignore\n          window.mapboxgl ||\n          window.maplibregl).LngLatBounds(\n          trace.features[0].geometry.coordinates[0],\n          trace.features[0].geometry.coordinates[0]\n        )\n      );\n      map.fitBounds(bounds, { padding: 50, duration: 2000 })\n\n      map.addSource('gp-base-ends', { type: 'geojson', data: ends })\n      map.addSource('gp-base-line', { type: 'geojson', data: trace })\n      map.addLayer({\n        id: 'gp-base-ends',\n        type: 'circle',\n        source: 'gp-base-ends',\n        layout: {},\n        paint: {\n          \"circle-radius\": 8,\n          \"circle-color\": \"red\",\n        },\n      })\n      map.addLayer({\n        id: 'gp-base-line',\n        type: 'line',\n        source: 'gp-base-line',\n        layout: {},\n        paint: {\n          'line-width': 3,\n          'line-color': 'red',\n          \"line-dasharray\": [3, 3],\n        }\n      })\n    })\n  }, [trace, ends]);\n\n  const handleSpeed = useCallback((e: React.FormEvent<HTMLInputElement>) => {\n    setSpeed(parseInt(e.currentTarget.value))\n  }, [])\n\n  const handleStart = useCallback(async () => {\n    const map = mapRef.current\n    if(map && trace && ends) {\n      const canvas = map.getCanvas();\n      const { startRecord, stopRecord } = createRecorder(canvas);\n      map.removeLayer('gp-base-line')\n      map.removeSource('gp-base-line')\n      map.removeLayer('gp-base-ends')\n      map.removeSource('gp-base-ends')\n\n      await sleep(1000);\n      setRecording(true);\n      startRecord();\n\n      await sleep(4000)\n      await animate(trace, ends, map, { speed })\n      await sleep(4000)\n\n      const url = await stopRecord();\n      setRecording(false);\n      download(url);\n    }\n  }, [trace, ends, speed])\n\n\n  const handleStop = useCallback(async () => {}, [])\n\n  if(!trace || !ends || !trace.features[0].properties || !trace.features[0].properties.durations) {\n    return (\n      <Dropzone onDrop={onDrop}>\n        {({getRootProps, getInputProps, isDragActive}) => (\n          <section className={classnames('dropzone', isDragActive ? 'dragging' : '' )} {...getRootProps()}>\n            <div className=\"inside\">\n              <input {...getInputProps()} />\n              <p>GeoJSON または GPX をドロップ</p>\n            </div>\n          </section>\n        )}\n      </Dropzone>\n    );\n  } else {\n    const count = trace.features[0].geometry.coordinates.length\n    const totalDuration = trace.features[0].properties.durations[count - 1]\n\n    return <GeoloniaMap\n      style={{width: '100%', height: '100%'}}\n      data-hash={'on'}\n      onLoad={onLoad}\n    >\n\n      <GeoloniaMap.Control\n        containerProps={ {className: 'slider-control speed-control maplibregl-ctrl mapboxgl-ctrl'} }\n        position={'top-left'}\n      >\n        <label htmlFor=\"speed\">speed</label>\n        <input\n          id={'speed'}\n          className={'slider'}\n          type=\"range\"\n          min={1}\n          max={10000}\n          value={speed}\n          onChange={handleSpeed}\n          disabled={recording}\n        />\n        <span>{`x ${speed} (${Math.round(100 * totalDuration / (1000 * speed)) / 100} sec.)`}</span>\n      </GeoloniaMap.Control>\n\n      <GeoloniaMap.Control\n        containerProps={ { className: classnames(\n          'button-control',\n          'record-start-control',\n          'maplibregl-ctrl',\n          'mapboxgl-ctrl',\n          'maplibregl-ctrl-group',\n          'mapboxgl-ctrl-group',\n          ) } }\n        position={'top-left'}\n      >\n        <button\n          onClick={recording ? handleStop : handleStart}\n          style={{display: 'flex', justifyContent: 'center', alignItems: 'center'}}\n        >\n          {recording ? <StopIcon sx={{color: 'red'}}></StopIcon> : <VideocamIcon></VideocamIcon>}\n        </button>\n      </GeoloniaMap.Control>\n    </GeoloniaMap>\n  }\n\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}